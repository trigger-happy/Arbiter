// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class NetworkMessage;
class RunOrder;
class ProblemSet;
class RunResult;
class Language;

enum NetworkMessage_MessageType {
  NetworkMessage_MessageType_CONNECT = 0,
  NetworkMessage_MessageType_CHALLENGE = 1,
  NetworkMessage_MessageType_CHALLENGE_RESPONSE = 2,
  NetworkMessage_MessageType_ACKNOWLEDGE = 3,
  NetworkMessage_MessageType_PING = 4,
  NetworkMessage_MessageType_PING_RESPONSE = 5,
  NetworkMessage_MessageType_RUN_ORDER = 6,
  NetworkMessage_MessageType_PROBLEM_SET_REQUEST = 7,
  NetworkMessage_MessageType_PROBLEM_SET = 8,
  NetworkMessage_MessageType_RUN_RESULT = 9,
  NetworkMessage_MessageType_LANGUAGE_REQUEST = 10,
  NetworkMessage_MessageType_LANGUAGE = 11
};
bool NetworkMessage_MessageType_IsValid(int value);
const NetworkMessage_MessageType NetworkMessage_MessageType_MessageType_MIN = NetworkMessage_MessageType_CONNECT;
const NetworkMessage_MessageType NetworkMessage_MessageType_MessageType_MAX = NetworkMessage_MessageType_LANGUAGE;
const int NetworkMessage_MessageType_MessageType_ARRAYSIZE = NetworkMessage_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkMessage_MessageType_descriptor();
inline const ::std::string& NetworkMessage_MessageType_Name(NetworkMessage_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkMessage_MessageType_descriptor(), value);
}
inline bool NetworkMessage_MessageType_Parse(
    const ::std::string& name, NetworkMessage_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkMessage_MessageType>(
    NetworkMessage_MessageType_descriptor(), name, value);
}
// ===================================================================

class NetworkMessage : public ::google::protobuf::Message {
 public:
  NetworkMessage();
  virtual ~NetworkMessage();
  
  NetworkMessage(const NetworkMessage& from);
  
  inline NetworkMessage& operator=(const NetworkMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkMessage& default_instance();
  
  void Swap(NetworkMessage* other);
  
  // implements Message ----------------------------------------------
  
  NetworkMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkMessage& from);
  void MergeFrom(const NetworkMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef NetworkMessage_MessageType MessageType;
  static const MessageType CONNECT = NetworkMessage_MessageType_CONNECT;
  static const MessageType CHALLENGE = NetworkMessage_MessageType_CHALLENGE;
  static const MessageType CHALLENGE_RESPONSE = NetworkMessage_MessageType_CHALLENGE_RESPONSE;
  static const MessageType ACKNOWLEDGE = NetworkMessage_MessageType_ACKNOWLEDGE;
  static const MessageType PING = NetworkMessage_MessageType_PING;
  static const MessageType PING_RESPONSE = NetworkMessage_MessageType_PING_RESPONSE;
  static const MessageType RUN_ORDER = NetworkMessage_MessageType_RUN_ORDER;
  static const MessageType PROBLEM_SET_REQUEST = NetworkMessage_MessageType_PROBLEM_SET_REQUEST;
  static const MessageType PROBLEM_SET = NetworkMessage_MessageType_PROBLEM_SET;
  static const MessageType RUN_RESULT = NetworkMessage_MessageType_RUN_RESULT;
  static const MessageType LANGUAGE_REQUEST = NetworkMessage_MessageType_LANGUAGE_REQUEST;
  static const MessageType LANGUAGE = NetworkMessage_MessageType_LANGUAGE;
  static inline bool MessageType_IsValid(int value) {
    return NetworkMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    NetworkMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    NetworkMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    NetworkMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return NetworkMessage_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return NetworkMessage_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return NetworkMessage_MessageType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .NetworkMessage.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NetworkMessage_MessageType type() const;
  inline void set_type(::NetworkMessage_MessageType value);
  
  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
  // optional uint32 requested_item_id = 3;
  inline bool has_requested_item_id() const;
  inline void clear_requested_item_id();
  static const int kRequestedItemIdFieldNumber = 3;
  inline ::google::protobuf::uint32 requested_item_id() const;
  inline void set_requested_item_id(::google::protobuf::uint32 value);
  
  // optional .RunOrder run_order = 4;
  inline bool has_run_order() const;
  inline void clear_run_order();
  static const int kRunOrderFieldNumber = 4;
  inline const ::RunOrder& run_order() const;
  inline ::RunOrder* mutable_run_order();
  
  // optional .ProblemSet problem_set = 5;
  inline bool has_problem_set() const;
  inline void clear_problem_set();
  static const int kProblemSetFieldNumber = 5;
  inline const ::ProblemSet& problem_set() const;
  inline ::ProblemSet* mutable_problem_set();
  
  // optional .RunResult run_result = 6;
  inline bool has_run_result() const;
  inline void clear_run_result();
  static const int kRunResultFieldNumber = 6;
  inline const ::RunResult& run_result() const;
  inline ::RunResult* mutable_run_result();
  
  // optional .Language language = 7;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 7;
  inline const ::Language& language() const;
  inline ::Language* mutable_language();
  
  // @@protoc_insertion_point(class_scope:NetworkMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::std::string* text_;
  static const ::std::string _default_text_;
  ::google::protobuf::uint32 requested_item_id_;
  ::RunOrder* run_order_;
  ::ProblemSet* problem_set_;
  ::RunResult* run_result_;
  ::Language* language_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NetworkMessage* default_instance_;
};
// -------------------------------------------------------------------

class RunOrder : public ::google::protobuf::Message {
 public:
  RunOrder();
  virtual ~RunOrder();
  
  RunOrder(const RunOrder& from);
  
  inline RunOrder& operator=(const RunOrder& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunOrder& default_instance();
  
  void Swap(RunOrder* other);
  
  // implements Message ----------------------------------------------
  
  RunOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunOrder& from);
  void MergeFrom(const RunOrder& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 problem_id = 1;
  inline bool has_problem_id() const;
  inline void clear_problem_id();
  static const int kProblemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 problem_id() const;
  inline void set_problem_id(::google::protobuf::uint32 value);
  
  // required string problem_hash = 2;
  inline bool has_problem_hash() const;
  inline void clear_problem_hash();
  static const int kProblemHashFieldNumber = 2;
  inline const ::std::string& problem_hash() const;
  inline void set_problem_hash(const ::std::string& value);
  inline void set_problem_hash(const char* value);
  inline void set_problem_hash(const char* value, size_t size);
  inline ::std::string* mutable_problem_hash();
  
  // required uint32 language_id = 3;
  inline bool has_language_id() const;
  inline void clear_language_id();
  static const int kLanguageIdFieldNumber = 3;
  inline ::google::protobuf::uint32 language_id() const;
  inline void set_language_id(::google::protobuf::uint32 value);
  
  // required string language_hash = 4;
  inline bool has_language_hash() const;
  inline void clear_language_hash();
  static const int kLanguageHashFieldNumber = 4;
  inline const ::std::string& language_hash() const;
  inline void set_language_hash(const ::std::string& value);
  inline void set_language_hash(const char* value);
  inline void set_language_hash(const char* value, size_t size);
  inline ::std::string* mutable_language_hash();
  
  // required uint32 run_id = 5;
  inline bool has_run_id() const;
  inline void clear_run_id();
  static const int kRunIdFieldNumber = 5;
  inline ::google::protobuf::uint32 run_id() const;
  inline void set_run_id(::google::protobuf::uint32 value);
  
  // required bytes attachment = 6;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 6;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const void* value, size_t size);
  inline ::std::string* mutable_attachment();
  
  // @@protoc_insertion_point(class_scope:RunOrder)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 problem_id_;
  ::std::string* problem_hash_;
  static const ::std::string _default_problem_hash_;
  ::google::protobuf::uint32 language_id_;
  ::std::string* language_hash_;
  static const ::std::string _default_language_hash_;
  ::google::protobuf::uint32 run_id_;
  ::std::string* attachment_;
  static const ::std::string _default_attachment_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RunOrder* default_instance_;
};
// -------------------------------------------------------------------

class ProblemSet : public ::google::protobuf::Message {
 public:
  ProblemSet();
  virtual ~ProblemSet();
  
  ProblemSet(const ProblemSet& from);
  
  inline ProblemSet& operator=(const ProblemSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProblemSet& default_instance();
  
  void Swap(ProblemSet* other);
  
  // implements Message ----------------------------------------------
  
  ProblemSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProblemSet& from);
  void MergeFrom(const ProblemSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string problem_id = 1;
  inline bool has_problem_id() const;
  inline void clear_problem_id();
  static const int kProblemIdFieldNumber = 1;
  inline const ::std::string& problem_id() const;
  inline void set_problem_id(const ::std::string& value);
  inline void set_problem_id(const char* value);
  inline void set_problem_id(const char* value, size_t size);
  inline ::std::string* mutable_problem_id();
  
  // required string problem_hash = 2;
  inline bool has_problem_hash() const;
  inline void clear_problem_hash();
  static const int kProblemHashFieldNumber = 2;
  inline const ::std::string& problem_hash() const;
  inline void set_problem_hash(const ::std::string& value);
  inline void set_problem_hash(const char* value);
  inline void set_problem_hash(const char* value, size_t size);
  inline ::std::string* mutable_problem_hash();
  
  // required bytes attachment = 3;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 3;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const void* value, size_t size);
  inline ::std::string* mutable_attachment();
  
  // @@protoc_insertion_point(class_scope:ProblemSet)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* problem_id_;
  static const ::std::string _default_problem_id_;
  ::std::string* problem_hash_;
  static const ::std::string _default_problem_hash_;
  ::std::string* attachment_;
  static const ::std::string _default_attachment_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProblemSet* default_instance_;
};
// -------------------------------------------------------------------

class RunResult : public ::google::protobuf::Message {
 public:
  RunResult();
  virtual ~RunResult();
  
  RunResult(const RunResult& from);
  
  inline RunResult& operator=(const RunResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunResult& default_instance();
  
  void Swap(RunResult* other);
  
  // implements Message ----------------------------------------------
  
  RunResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunResult& from);
  void MergeFrom(const RunResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 run_id = 1;
  inline bool has_run_id() const;
  inline void clear_run_id();
  static const int kRunIdFieldNumber = 1;
  inline ::google::protobuf::uint32 run_id() const;
  inline void set_run_id(::google::protobuf::uint32 value);
  
  // required uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional string team_stdout = 3;
  inline bool has_team_stdout() const;
  inline void clear_team_stdout();
  static const int kTeamStdoutFieldNumber = 3;
  inline const ::std::string& team_stdout() const;
  inline void set_team_stdout(const ::std::string& value);
  inline void set_team_stdout(const char* value);
  inline void set_team_stdout(const char* value, size_t size);
  inline ::std::string* mutable_team_stdout();
  
  // optional string team_stderr = 4;
  inline bool has_team_stderr() const;
  inline void clear_team_stderr();
  static const int kTeamStderrFieldNumber = 4;
  inline const ::std::string& team_stderr() const;
  inline void set_team_stderr(const ::std::string& value);
  inline void set_team_stderr(const char* value);
  inline void set_team_stderr(const char* value, size_t size);
  inline ::std::string* mutable_team_stderr();
  
  // optional uint64 run_time = 5;
  inline bool has_run_time() const;
  inline void clear_run_time();
  static const int kRunTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 run_time() const;
  inline void set_run_time(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:RunResult)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 run_id_;
  ::google::protobuf::uint32 result_;
  ::std::string* team_stdout_;
  static const ::std::string _default_team_stdout_;
  ::std::string* team_stderr_;
  static const ::std::string _default_team_stderr_;
  ::google::protobuf::uint64 run_time_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RunResult* default_instance_;
};
// -------------------------------------------------------------------

class Language : public ::google::protobuf::Message {
 public:
  Language();
  virtual ~Language();
  
  Language(const Language& from);
  
  inline Language& operator=(const Language& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Language& default_instance();
  
  void Swap(Language* other);
  
  // implements Message ----------------------------------------------
  
  Language* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Language& from);
  void MergeFrom(const Language& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 language_id = 1;
  inline bool has_language_id() const;
  inline void clear_language_id();
  static const int kLanguageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 language_id() const;
  inline void set_language_id(::google::protobuf::uint32 value);
  
  // required string language_hash = 2;
  inline bool has_language_hash() const;
  inline void clear_language_hash();
  static const int kLanguageHashFieldNumber = 2;
  inline const ::std::string& language_hash() const;
  inline void set_language_hash(const ::std::string& value);
  inline void set_language_hash(const char* value);
  inline void set_language_hash(const char* value, size_t size);
  inline ::std::string* mutable_language_hash();
  
  // required bytes attachment = 3;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 3;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const void* value, size_t size);
  inline ::std::string* mutable_attachment();
  
  // @@protoc_insertion_point(class_scope:Language)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 language_id_;
  ::std::string* language_hash_;
  static const ::std::string _default_language_hash_;
  ::std::string* attachment_;
  static const ::std::string _default_attachment_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Language* default_instance_;
};
// ===================================================================


// ===================================================================

// NetworkMessage

// required .NetworkMessage.MessageType type = 1;
inline bool NetworkMessage::has_type() const {
  return _has_bit(0);
}
inline void NetworkMessage::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::NetworkMessage_MessageType NetworkMessage::type() const {
  return static_cast< ::NetworkMessage_MessageType >(type_);
}
inline void NetworkMessage::set_type(::NetworkMessage_MessageType value) {
  GOOGLE_DCHECK(::NetworkMessage_MessageType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional string text = 2;
inline bool NetworkMessage::has_text() const {
  return _has_bit(1);
}
inline void NetworkMessage::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& NetworkMessage::text() const {
  return *text_;
}
inline void NetworkMessage::set_text(const ::std::string& value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void NetworkMessage::set_text(const char* value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void NetworkMessage::set_text(const char* value, size_t size) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetworkMessage::mutable_text() {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}

// optional uint32 requested_item_id = 3;
inline bool NetworkMessage::has_requested_item_id() const {
  return _has_bit(2);
}
inline void NetworkMessage::clear_requested_item_id() {
  requested_item_id_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 NetworkMessage::requested_item_id() const {
  return requested_item_id_;
}
inline void NetworkMessage::set_requested_item_id(::google::protobuf::uint32 value) {
  _set_bit(2);
  requested_item_id_ = value;
}

// optional .RunOrder run_order = 4;
inline bool NetworkMessage::has_run_order() const {
  return _has_bit(3);
}
inline void NetworkMessage::clear_run_order() {
  if (run_order_ != NULL) run_order_->::RunOrder::Clear();
  _clear_bit(3);
}
inline const ::RunOrder& NetworkMessage::run_order() const {
  return run_order_ != NULL ? *run_order_ : *default_instance_->run_order_;
}
inline ::RunOrder* NetworkMessage::mutable_run_order() {
  _set_bit(3);
  if (run_order_ == NULL) run_order_ = new ::RunOrder;
  return run_order_;
}

// optional .ProblemSet problem_set = 5;
inline bool NetworkMessage::has_problem_set() const {
  return _has_bit(4);
}
inline void NetworkMessage::clear_problem_set() {
  if (problem_set_ != NULL) problem_set_->::ProblemSet::Clear();
  _clear_bit(4);
}
inline const ::ProblemSet& NetworkMessage::problem_set() const {
  return problem_set_ != NULL ? *problem_set_ : *default_instance_->problem_set_;
}
inline ::ProblemSet* NetworkMessage::mutable_problem_set() {
  _set_bit(4);
  if (problem_set_ == NULL) problem_set_ = new ::ProblemSet;
  return problem_set_;
}

// optional .RunResult run_result = 6;
inline bool NetworkMessage::has_run_result() const {
  return _has_bit(5);
}
inline void NetworkMessage::clear_run_result() {
  if (run_result_ != NULL) run_result_->::RunResult::Clear();
  _clear_bit(5);
}
inline const ::RunResult& NetworkMessage::run_result() const {
  return run_result_ != NULL ? *run_result_ : *default_instance_->run_result_;
}
inline ::RunResult* NetworkMessage::mutable_run_result() {
  _set_bit(5);
  if (run_result_ == NULL) run_result_ = new ::RunResult;
  return run_result_;
}

// optional .Language language = 7;
inline bool NetworkMessage::has_language() const {
  return _has_bit(6);
}
inline void NetworkMessage::clear_language() {
  if (language_ != NULL) language_->::Language::Clear();
  _clear_bit(6);
}
inline const ::Language& NetworkMessage::language() const {
  return language_ != NULL ? *language_ : *default_instance_->language_;
}
inline ::Language* NetworkMessage::mutable_language() {
  _set_bit(6);
  if (language_ == NULL) language_ = new ::Language;
  return language_;
}

// -------------------------------------------------------------------

// RunOrder

// required uint32 problem_id = 1;
inline bool RunOrder::has_problem_id() const {
  return _has_bit(0);
}
inline void RunOrder::clear_problem_id() {
  problem_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RunOrder::problem_id() const {
  return problem_id_;
}
inline void RunOrder::set_problem_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  problem_id_ = value;
}

// required string problem_hash = 2;
inline bool RunOrder::has_problem_hash() const {
  return _has_bit(1);
}
inline void RunOrder::clear_problem_hash() {
  if (problem_hash_ != &_default_problem_hash_) {
    problem_hash_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RunOrder::problem_hash() const {
  return *problem_hash_;
}
inline void RunOrder::set_problem_hash(const ::std::string& value) {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  problem_hash_->assign(value);
}
inline void RunOrder::set_problem_hash(const char* value) {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  problem_hash_->assign(value);
}
inline void RunOrder::set_problem_hash(const char* value, size_t size) {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  problem_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunOrder::mutable_problem_hash() {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  return problem_hash_;
}

// required uint32 language_id = 3;
inline bool RunOrder::has_language_id() const {
  return _has_bit(2);
}
inline void RunOrder::clear_language_id() {
  language_id_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 RunOrder::language_id() const {
  return language_id_;
}
inline void RunOrder::set_language_id(::google::protobuf::uint32 value) {
  _set_bit(2);
  language_id_ = value;
}

// required string language_hash = 4;
inline bool RunOrder::has_language_hash() const {
  return _has_bit(3);
}
inline void RunOrder::clear_language_hash() {
  if (language_hash_ != &_default_language_hash_) {
    language_hash_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RunOrder::language_hash() const {
  return *language_hash_;
}
inline void RunOrder::set_language_hash(const ::std::string& value) {
  _set_bit(3);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  language_hash_->assign(value);
}
inline void RunOrder::set_language_hash(const char* value) {
  _set_bit(3);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  language_hash_->assign(value);
}
inline void RunOrder::set_language_hash(const char* value, size_t size) {
  _set_bit(3);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  language_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunOrder::mutable_language_hash() {
  _set_bit(3);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  return language_hash_;
}

// required uint32 run_id = 5;
inline bool RunOrder::has_run_id() const {
  return _has_bit(4);
}
inline void RunOrder::clear_run_id() {
  run_id_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 RunOrder::run_id() const {
  return run_id_;
}
inline void RunOrder::set_run_id(::google::protobuf::uint32 value) {
  _set_bit(4);
  run_id_ = value;
}

// required bytes attachment = 6;
inline bool RunOrder::has_attachment() const {
  return _has_bit(5);
}
inline void RunOrder::clear_attachment() {
  if (attachment_ != &_default_attachment_) {
    attachment_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& RunOrder::attachment() const {
  return *attachment_;
}
inline void RunOrder::set_attachment(const ::std::string& value) {
  _set_bit(5);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void RunOrder::set_attachment(const char* value) {
  _set_bit(5);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void RunOrder::set_attachment(const void* value, size_t size) {
  _set_bit(5);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunOrder::mutable_attachment() {
  _set_bit(5);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  return attachment_;
}

// -------------------------------------------------------------------

// ProblemSet

// required string problem_id = 1;
inline bool ProblemSet::has_problem_id() const {
  return _has_bit(0);
}
inline void ProblemSet::clear_problem_id() {
  if (problem_id_ != &_default_problem_id_) {
    problem_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ProblemSet::problem_id() const {
  return *problem_id_;
}
inline void ProblemSet::set_problem_id(const ::std::string& value) {
  _set_bit(0);
  if (problem_id_ == &_default_problem_id_) {
    problem_id_ = new ::std::string;
  }
  problem_id_->assign(value);
}
inline void ProblemSet::set_problem_id(const char* value) {
  _set_bit(0);
  if (problem_id_ == &_default_problem_id_) {
    problem_id_ = new ::std::string;
  }
  problem_id_->assign(value);
}
inline void ProblemSet::set_problem_id(const char* value, size_t size) {
  _set_bit(0);
  if (problem_id_ == &_default_problem_id_) {
    problem_id_ = new ::std::string;
  }
  problem_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProblemSet::mutable_problem_id() {
  _set_bit(0);
  if (problem_id_ == &_default_problem_id_) {
    problem_id_ = new ::std::string;
  }
  return problem_id_;
}

// required string problem_hash = 2;
inline bool ProblemSet::has_problem_hash() const {
  return _has_bit(1);
}
inline void ProblemSet::clear_problem_hash() {
  if (problem_hash_ != &_default_problem_hash_) {
    problem_hash_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ProblemSet::problem_hash() const {
  return *problem_hash_;
}
inline void ProblemSet::set_problem_hash(const ::std::string& value) {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  problem_hash_->assign(value);
}
inline void ProblemSet::set_problem_hash(const char* value) {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  problem_hash_->assign(value);
}
inline void ProblemSet::set_problem_hash(const char* value, size_t size) {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  problem_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProblemSet::mutable_problem_hash() {
  _set_bit(1);
  if (problem_hash_ == &_default_problem_hash_) {
    problem_hash_ = new ::std::string;
  }
  return problem_hash_;
}

// required bytes attachment = 3;
inline bool ProblemSet::has_attachment() const {
  return _has_bit(2);
}
inline void ProblemSet::clear_attachment() {
  if (attachment_ != &_default_attachment_) {
    attachment_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ProblemSet::attachment() const {
  return *attachment_;
}
inline void ProblemSet::set_attachment(const ::std::string& value) {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void ProblemSet::set_attachment(const char* value) {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void ProblemSet::set_attachment(const void* value, size_t size) {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProblemSet::mutable_attachment() {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  return attachment_;
}

// -------------------------------------------------------------------

// RunResult

// required uint32 run_id = 1;
inline bool RunResult::has_run_id() const {
  return _has_bit(0);
}
inline void RunResult::clear_run_id() {
  run_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RunResult::run_id() const {
  return run_id_;
}
inline void RunResult::set_run_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  run_id_ = value;
}

// required uint32 result = 2;
inline bool RunResult::has_result() const {
  return _has_bit(1);
}
inline void RunResult::clear_result() {
  result_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 RunResult::result() const {
  return result_;
}
inline void RunResult::set_result(::google::protobuf::uint32 value) {
  _set_bit(1);
  result_ = value;
}

// optional string team_stdout = 3;
inline bool RunResult::has_team_stdout() const {
  return _has_bit(2);
}
inline void RunResult::clear_team_stdout() {
  if (team_stdout_ != &_default_team_stdout_) {
    team_stdout_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RunResult::team_stdout() const {
  return *team_stdout_;
}
inline void RunResult::set_team_stdout(const ::std::string& value) {
  _set_bit(2);
  if (team_stdout_ == &_default_team_stdout_) {
    team_stdout_ = new ::std::string;
  }
  team_stdout_->assign(value);
}
inline void RunResult::set_team_stdout(const char* value) {
  _set_bit(2);
  if (team_stdout_ == &_default_team_stdout_) {
    team_stdout_ = new ::std::string;
  }
  team_stdout_->assign(value);
}
inline void RunResult::set_team_stdout(const char* value, size_t size) {
  _set_bit(2);
  if (team_stdout_ == &_default_team_stdout_) {
    team_stdout_ = new ::std::string;
  }
  team_stdout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunResult::mutable_team_stdout() {
  _set_bit(2);
  if (team_stdout_ == &_default_team_stdout_) {
    team_stdout_ = new ::std::string;
  }
  return team_stdout_;
}

// optional string team_stderr = 4;
inline bool RunResult::has_team_stderr() const {
  return _has_bit(3);
}
inline void RunResult::clear_team_stderr() {
  if (team_stderr_ != &_default_team_stderr_) {
    team_stderr_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RunResult::team_stderr() const {
  return *team_stderr_;
}
inline void RunResult::set_team_stderr(const ::std::string& value) {
  _set_bit(3);
  if (team_stderr_ == &_default_team_stderr_) {
    team_stderr_ = new ::std::string;
  }
  team_stderr_->assign(value);
}
inline void RunResult::set_team_stderr(const char* value) {
  _set_bit(3);
  if (team_stderr_ == &_default_team_stderr_) {
    team_stderr_ = new ::std::string;
  }
  team_stderr_->assign(value);
}
inline void RunResult::set_team_stderr(const char* value, size_t size) {
  _set_bit(3);
  if (team_stderr_ == &_default_team_stderr_) {
    team_stderr_ = new ::std::string;
  }
  team_stderr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunResult::mutable_team_stderr() {
  _set_bit(3);
  if (team_stderr_ == &_default_team_stderr_) {
    team_stderr_ = new ::std::string;
  }
  return team_stderr_;
}

// optional uint64 run_time = 5;
inline bool RunResult::has_run_time() const {
  return _has_bit(4);
}
inline void RunResult::clear_run_time() {
  run_time_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 RunResult::run_time() const {
  return run_time_;
}
inline void RunResult::set_run_time(::google::protobuf::uint64 value) {
  _set_bit(4);
  run_time_ = value;
}

// -------------------------------------------------------------------

// Language

// required uint32 language_id = 1;
inline bool Language::has_language_id() const {
  return _has_bit(0);
}
inline void Language::clear_language_id() {
  language_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 Language::language_id() const {
  return language_id_;
}
inline void Language::set_language_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  language_id_ = value;
}

// required string language_hash = 2;
inline bool Language::has_language_hash() const {
  return _has_bit(1);
}
inline void Language::clear_language_hash() {
  if (language_hash_ != &_default_language_hash_) {
    language_hash_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Language::language_hash() const {
  return *language_hash_;
}
inline void Language::set_language_hash(const ::std::string& value) {
  _set_bit(1);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  language_hash_->assign(value);
}
inline void Language::set_language_hash(const char* value) {
  _set_bit(1);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  language_hash_->assign(value);
}
inline void Language::set_language_hash(const char* value, size_t size) {
  _set_bit(1);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  language_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Language::mutable_language_hash() {
  _set_bit(1);
  if (language_hash_ == &_default_language_hash_) {
    language_hash_ = new ::std::string;
  }
  return language_hash_;
}

// required bytes attachment = 3;
inline bool Language::has_attachment() const {
  return _has_bit(2);
}
inline void Language::clear_attachment() {
  if (attachment_ != &_default_attachment_) {
    attachment_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Language::attachment() const {
  return *attachment_;
}
inline void Language::set_attachment(const ::std::string& value) {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Language::set_attachment(const char* value) {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Language::set_attachment(const void* value, size_t size) {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Language::mutable_attachment() {
  _set_bit(2);
  if (attachment_ == &_default_attachment_) {
    attachment_ = new ::std::string;
  }
  return attachment_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetworkMessage_MessageType>() {
  return ::NetworkMessage_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
